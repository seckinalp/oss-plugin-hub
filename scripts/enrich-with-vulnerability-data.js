#!/usr/bin/env node

/**
 * Enrich top100.json files with vulnerability analysis data
 * Adds vulnerability metrics from OSV scans to each plugin
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const DATA_DIR = path.join(__dirname, '../data');
const PLATFORMS = [
  'chrome',
  'firefox',
  'homeassistant',
  'jetbrains',
  'minecraft',
  'obsidian',
  'sublime',
  'vscode',
  'wordpress',
];
const OSV_SCANS_DIR = path.join(DATA_DIR, 'osv-scans');
const SBOM_DIR = path.join(DATA_DIR, 'sbom');

console.log('=== Enriching top100.json with Vulnerability Data ===\n');

function main() {
  // Load all analysis files
  const analysisMap = new Map();
  const osvScanMap = new Map();
  const sbomMap = new Set();
  
  // Load analysis files
  const analysisFiles = fs.readdirSync(OSV_SCANS_DIR)
    .filter(f => f.endsWith('.analysis.json'));
  
  analysisFiles.forEach(file => {
    const repo = file.replace('.analysis.json', '').replace(/__/g, '/');
    const data = JSON.parse(fs.readFileSync(path.join(OSV_SCANS_DIR, file), 'utf8'));
    analysisMap.set(repo, data);
  });
  
  // Load OSV scan files (to check if scanned but not analyzed)
  const osvFiles = fs.readdirSync(OSV_SCANS_DIR)
    .filter(f => f.endsWith('.osv.json'));
  
  osvFiles.forEach(file => {
    const repo = file.replace('.osv.json', '').replace(/__/g, '/');
    osvScanMap.set(repo, true);
  });
  
  // Load SBOM files
  const sbomFiles = fs.readdirSync(SBOM_DIR)
    .filter(f => f.endsWith('.sbom.json'));
  
  sbomFiles.forEach(file => {
    const repo = file.replace('.sbom.json', '').replace(/__/g, '/');
    sbomMap.add(repo);
  });
  
  console.log(`Loaded ${analysisMap.size} analysis files`);
  console.log(`Loaded ${osvScanMap.size} OSV scan files`);
  console.log(`Loaded ${sbomMap.size} SBOM files\n`);
  
  let totalPlugins = 0;
  let pluginsWithAnalysis = 0;
  let pluginsWithSbomNoScan = 0;
  let pluginsNoSbom = 0;
  let pluginsNoRepo = 0;
  
  // Process each platform
  for (const platform of PLATFORMS) {
    const filePath = path.join(DATA_DIR, platform, 'top100.json');
    
    if (!fs.existsSync(filePath)) {
      console.log(`âš ï¸  Skipping ${platform}: file not found`);
      continue;
    }
    
    const data = JSON.parse(fs.readFileSync(filePath, 'utf8'));
    let platformAnalyzed = 0;
    let platformNoSbom = 0;
    let platformNoScan = 0;
    let platformNoRepo = 0;
    
    // Enrich each plugin
    data.top100.forEach(plugin => {
      totalPlugins++;
      
      if (!plugin.repo) {
        // No GitHub repo
        plugin.vulnerabilityAnalysis = {
          status: 'no_repo',
          message: 'No GitHub repository available',
          analyzed: false,
        };
        pluginsNoRepo++;
        platformNoRepo++;
        return;
      }
      
      const repo = plugin.repo;
      
      if (analysisMap.has(repo)) {
        // Has analysis data
        const analysis = analysisMap.get(repo);
        const riskLevel = determineRiskLevel(analysis.summary);
        const staleByTime = categorizeStalePackages(analysis.staleDependencies || []);
        
        plugin.vulnerabilityAnalysis = {
          status: 'analyzed',
          analyzed: true,
          analyzedAt: analysis.analyzedAt || new Date().toISOString(),
          summary: {
            totalVulnerabilities: analysis.summary.totalVulnerabilities,
            criticalVulnerabilities: analysis.summary.severityBreakdown.CRITICAL,
            highVulnerabilities: analysis.summary.severityBreakdown.HIGH,
            mediumVulnerabilities: analysis.summary.severityBreakdown.MEDIUM,
            lowVulnerabilities: analysis.summary.severityBreakdown.LOW,
            stalePackages: analysis.summary.stalePackages,
            stalePackages6Months: staleByTime.sixMonths,
            stalePackages1Year: staleByTime.oneYear,
            stalePackages2Years: staleByTime.twoYears,
            stalePackages3YearsPlus: staleByTime.threePlus,
            recentVulnerabilities: analysis.summary.recentVulnerabilities || 0,
          },
          riskLevel: riskLevel,
          riskDescription: getRiskDescription(riskLevel, analysis.summary),
        };
        pluginsWithAnalysis++;
        platformAnalyzed++;
      } else if (sbomMap.has(repo)) {
        // Has SBOM but no scan/analysis
        if (osvScanMap.has(repo)) {
          plugin.vulnerabilityAnalysis = {
            status: 'scan_failed',
            message: 'OSV scan completed but analysis failed',
            analyzed: false,
          };
        } else {
          plugin.vulnerabilityAnalysis = {
            status: 'not_scanned',
            message: 'SBOM available but not yet scanned with OSV',
            analyzed: false,
          };
        }
        pluginsWithSbomNoScan++;
        platformNoScan++;
      } else {
        // No SBOM available
        plugin.vulnerabilityAnalysis = {
          status: 'no_sbom',
          message: 'SBOM not available from GitHub (repository has no analyzable dependencies or uses unsupported package manager)',
          analyzed: false,
        };
        pluginsNoSbom++;
        platformNoSbom++;
      }
    });
    
    // Update metadata
    data.metadata = data.metadata || {};
    data.metadata.lastVulnerabilityUpdate = new Date().toISOString();
    data.metadata.vulnerabilityAnalysis = {
      total: data.top100.length,
      analyzed: platformAnalyzed,
      noSbom: platformNoSbom,
      notScanned: platformNoScan,
      noRepo: platformNoRepo,
    };
    
    // Save updated file
    fs.writeFileSync(filePath, JSON.stringify(data, null, 2));
    
    console.log(`âœ… ${platform}:`);
    console.log(`   Total: ${data.top100.length}`);
    console.log(`   Analyzed: ${platformAnalyzed}`);
    console.log(`   No SBOM: ${platformNoSbom}`);
    console.log(`   Not scanned: ${platformNoScan}`);
    console.log(`   No repo: ${platformNoRepo}`);
  }
  
  console.log('\n======================================');
  console.log('Enrichment Complete!');
  console.log('======================================\n');
  
  console.log('Overall Statistics:');
  console.log(`  Total plugins: ${totalPlugins}`);
  console.log(`  âœ… With analysis: ${pluginsWithAnalysis} (${(pluginsWithAnalysis/totalPlugins*100).toFixed(1)}%)`);
  console.log(`  ðŸ“¦ SBOM but no scan: ${pluginsWithSbomNoScan} (${(pluginsWithSbomNoScan/totalPlugins*100).toFixed(1)}%)`);
  console.log(`  âŒ No SBOM: ${pluginsNoSbom} (${(pluginsNoSbom/totalPlugins*100).toFixed(1)}%)`);
  console.log(`  ðŸ”— No repo: ${pluginsNoRepo} (${(pluginsNoRepo/totalPlugins*100).toFixed(1)}%)`);
  console.log('');
  
  console.log('ðŸ’¡ Data Structure Added:');
  console.log('  Each plugin now has a "vulnerabilityAnalysis" field with:');
  console.log('    - status: "analyzed" | "no_sbom" | "not_scanned" | "scan_failed" | "no_repo"');
  console.log('    - analyzed: boolean');
  console.log('    - summary: { vulnerabilities, severity breakdown, stale packages }');
  console.log('    - riskLevel: "critical" | "high" | "medium" | "low" | "clean"');
  console.log('    - message: explanation for non-analyzed plugins');
  console.log('');
}

function determineRiskLevel(summary) {
  if (summary.severityBreakdown.CRITICAL > 0) {
    return 'critical';
  }
  if (summary.severityBreakdown.HIGH > 0) {
    return 'high';
  }
  if (summary.severityBreakdown.MEDIUM > 0) {
    return 'medium';
  }
  if (summary.severityBreakdown.LOW > 0) {
    return 'low';
  }
  return 'clean';
}

function getRiskDescription(riskLevel, summary) {
  const descriptions = {
    critical: `Contains ${summary.severityBreakdown.CRITICAL} CRITICAL severity vulnerability(ies) that pose immediate security risks and should be addressed urgently. These vulnerabilities have severe impacts and are often actively exploited.`,
    high: `Contains ${summary.severityBreakdown.HIGH} HIGH severity vulnerability(ies) that pose significant security risks. These issues should be prioritized for remediation as they can lead to serious security breaches.`,
    medium: `Contains ${summary.severityBreakdown.MEDIUM} MEDIUM severity vulnerability(ies) that present moderate security concerns. While not immediately critical, these should be addressed in regular security updates.`,
    low: `Contains ${summary.severityBreakdown.LOW} LOW severity vulnerability(ies) with minimal security impact. These are less urgent but should still be tracked and resolved during routine maintenance.`,
    clean: 'No known vulnerabilities detected in dependencies. This indicates good security hygiene, though regular monitoring is still recommended.',
  };
  
  return descriptions[riskLevel] || 'Risk level assessment unavailable.';
}

function categorizeStalePackages(staleDependencies) {
  const categories = {
    sixMonths: 0,   // 6 months to 1 year
    oneYear: 0,     // 1 year to 2 years
    twoYears: 0,    // 2 years to 3 years
    threePlus: 0,   // 3+ years
  };
  
  staleDependencies.forEach(dep => {
    if (!dep.monthsSinceFix) return;
    
    const months = dep.monthsSinceFix;
    
    if (months >= 6 && months < 12) {
      categories.sixMonths++;
    } else if (months >= 12 && months < 24) {
      categories.oneYear++;
    } else if (months >= 24 && months < 36) {
      categories.twoYears++;
    } else if (months >= 36) {
      categories.threePlus++;
    }
  });
  
  return categories;
}

main();














