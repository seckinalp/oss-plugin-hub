#!/usr/bin/env node

/**
 * Generate Vulnerability Summary Report
 * Aggregates all vulnerability analyses into a single summary
 * Output: data/vulnerability-summary.json
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const OSV_SCANS_DIR = path.join(__dirname, '../data/osv-scans');
const OUTPUT_FILE = path.join(__dirname, '../data/vulnerability-summary.json');

console.log('=== Generating Vulnerability Summary ===\n');

function main() {
  const analysisFiles = fs.readdirSync(OSV_SCANS_DIR)
    .filter(f => f.endsWith('.analysis.json'));
  
  console.log(`Processing ${analysisFiles.length} analysis files...\n`);
  
  const summary = {
    generatedAt: new Date().toISOString(),
    totalPluginsAnalyzed: analysisFiles.length,
    overall: {
      totalVulnerabilities: 0,
      uniqueVulnerabilities: new Set(),
      affectedPlugins: 0,
      cleanPlugins: 0,
      severityBreakdown: { CRITICAL: 0, HIGH: 0, MEDIUM: 0, LOW: 0 },
      stalePackages: 0,
      oldFixesAvailable: 0,
      recentVulnerabilities: 0,
    },
    highRiskPlugins: [],
    mostVulnerable: [],
    stalestDependencies: [],
    byPlatform: {},
    bySeverity: {
      critical: [],
      high: [],
      medium: [],
      low: [],
    },
  };
  
  const allStale = [];
  
  for (const file of analysisFiles) {
    const data = JSON.parse(fs.readFileSync(path.join(OSV_SCANS_DIR, file), 'utf8'));
    const s = data.summary;
    const pluginName = file.replace('.analysis.json', '').replace(/__/g, '/');
    
    // Extract platform from filename or repo
    const platform = detectPlatform(pluginName, data);
    
    if (!summary.byPlatform[platform]) {
      summary.byPlatform[platform] = {
        total: 0,
        vulnerabilities: 0,
        critical: 0,
        high: 0,
        medium: 0,
        low: 0,
        stale: 0,
        oldFixes: 0,
      };
    }
    
    summary.byPlatform[platform].total++;
    summary.byPlatform[platform].vulnerabilities += s.totalVulnerabilities;
    summary.byPlatform[platform].critical += s.severityBreakdown.CRITICAL;
    summary.byPlatform[platform].high += s.severityBreakdown.HIGH;
    summary.byPlatform[platform].medium += s.severityBreakdown.MEDIUM;
    summary.byPlatform[platform].low += s.severityBreakdown.LOW;
    summary.byPlatform[platform].stale += s.stalePackages;
    summary.byPlatform[platform].oldFixes += s.stalePackagesOldFix || 0;
    
    summary.overall.totalVulnerabilities += s.totalVulnerabilities;
    summary.overall.severityBreakdown.CRITICAL += s.severityBreakdown.CRITICAL;
    summary.overall.severityBreakdown.HIGH += s.severityBreakdown.HIGH;
    summary.overall.severityBreakdown.MEDIUM += s.severityBreakdown.MEDIUM;
    summary.overall.severityBreakdown.LOW += s.severityBreakdown.LOW;
    summary.overall.stalePackages += s.stalePackages;
    summary.overall.oldFixesAvailable += s.stalePackagesOldFix || 0;
    summary.overall.recentVulnerabilities += s.recentVulnerabilities;
    
    // Track unique vulnerabilities
    data.vulnerabilities.forEach(v => {
      summary.overall.uniqueVulnerabilities.add(v.id);
    });
    
    // Count clean vs affected
    if (s.totalVulnerabilities === 0) {
      summary.overall.cleanPlugins++;
    } else {
      summary.overall.affectedPlugins++;
    }
    
    // High-risk plugins (CRITICAL or HIGH)
    if (s.severityBreakdown.CRITICAL > 0 || s.severityBreakdown.HIGH > 0) {
      summary.highRiskPlugins.push({
        plugin: pluginName,
        platform,
        critical: s.severityBreakdown.CRITICAL,
        high: s.severityBreakdown.HIGH,
        medium: s.severityBreakdown.MEDIUM,
        total: s.totalVulnerabilities,
        oldFixes: s.stalePackagesOldFix || 0,
      });
    }
    
    // Collect stale dependencies
    if (data.staleDependencies) {
      data.staleDependencies.forEach(dep => {
        allStale.push({
          ...dep,
          plugin: pluginName,
          platform,
        });
      });
    }
    
    // Most vulnerable
    if (s.totalVulnerabilities > 0) {
      summary.mostVulnerable.push({
        plugin: pluginName,
        platform,
        vulnerabilities: s.totalVulnerabilities,
        critical: s.severityBreakdown.CRITICAL,
        high: s.severityBreakdown.HIGH,
        medium: s.severityBreakdown.MEDIUM,
        low: s.severityBreakdown.LOW,
        stale: s.stalePackages,
        oldFixes: s.stalePackagesOldFix || 0,
      });
    }
    
    // Categorize by worst severity
    if (s.severityBreakdown.CRITICAL > 0) {
      summary.bySeverity.critical.push({ plugin: pluginName, platform, count: s.severityBreakdown.CRITICAL });
    } else if (s.severityBreakdown.HIGH > 0) {
      summary.bySeverity.high.push({ plugin: pluginName, platform, count: s.severityBreakdown.HIGH });
    } else if (s.severityBreakdown.MEDIUM > 0) {
      summary.bySeverity.medium.push({ plugin: pluginName, platform, count: s.severityBreakdown.MEDIUM });
    } else if (s.severityBreakdown.LOW > 0) {
      summary.bySeverity.low.push({ plugin: pluginName, platform, count: s.severityBreakdown.LOW });
    }
  }
  
  // Convert unique vulnerabilities set to count
  summary.overall.uniqueVulnerabilities = summary.overall.uniqueVulnerabilities.size;
  
  // Sort arrays
  summary.highRiskPlugins.sort((a, b) => 
    (b.critical * 1000 + b.high * 100 + b.medium) - 
    (a.critical * 1000 + a.high * 100 + a.medium)
  );
  
  summary.mostVulnerable.sort((a, b) => b.vulnerabilities - a.vulnerabilities);
  summary.mostVulnerable = summary.mostVulnerable.slice(0, 50);
  
  // Top 50 stalest dependencies
  summary.stalestDependencies = allStale
    .sort((a, b) => b.daysSinceFix - a.daysSinceFix)
    .slice(0, 50);
  
  // Sort severity categories
  summary.bySeverity.critical.sort((a, b) => b.count - a.count);
  summary.bySeverity.high.sort((a, b) => b.count - a.count);
  summary.bySeverity.medium.sort((a, b) => b.count - a.count);
  
  // Save
  fs.writeFileSync(OUTPUT_FILE, JSON.stringify(summary, null, 2));
  
  // Display
  console.log('======================================');
  console.log('Summary Complete!');
  console.log('======================================\n');
  
  console.log('Overall Statistics:');
  console.log(`  Plugins analyzed: ${summary.totalPluginsAnalyzed}`);
  console.log(`  Total vulnerabilities: ${summary.overall.totalVulnerabilities.toLocaleString()}`);
  console.log(`  Unique CVEs/GHSAs: ${summary.overall.uniqueVulnerabilities}`);
  console.log(`  Affected plugins: ${summary.overall.affectedPlugins}`);
  console.log(`  Clean plugins: ${summary.overall.cleanPlugins}`);
  console.log('');
  
  console.log('Severity Breakdown:');
  console.log(`  ðŸ”´ CRITICAL: ${summary.overall.severityBreakdown.CRITICAL}`);
  console.log(`  ðŸŸ  HIGH: ${summary.overall.severityBreakdown.HIGH}`);
  console.log(`  ðŸŸ¡ MEDIUM: ${summary.overall.severityBreakdown.MEDIUM}`);
  console.log(`  ðŸŸ¢ LOW: ${summary.overall.severityBreakdown.LOW}`);
  console.log('');
  
  console.log('Dependency Health:');
  console.log(`  Stale packages: ${summary.overall.stalePackages.toLocaleString()}`);
  console.log(`  ðŸš¨ Old fixes (>6mo): ${summary.overall.oldFixesAvailable.toLocaleString()}`);
  console.log(`  Recent vulnerabilities: ${summary.overall.recentVulnerabilities}`);
  console.log('');
  
  console.log('High-Risk Plugins:');
  console.log(`  With CRITICAL/HIGH: ${summary.highRiskPlugins.length}`);
  if (summary.highRiskPlugins.length > 0) {
    summary.highRiskPlugins.slice(0, 5).forEach((p, i) => {
      console.log(`  ${i + 1}. ${p.plugin}: ${p.critical} CRIT, ${p.high} HIGH, ${p.medium} MED`);
    });
  }
  console.log('');
  
  console.log('By Platform:');
  Object.entries(summary.byPlatform)
    .sort((a, b) => b[1].vulnerabilities - a[1].vulnerabilities)
    .forEach(([platform, stats]) => {
      console.log(`  ${platform}: ${stats.vulnerabilities} vulns (${stats.critical} CRIT, ${stats.high} HIGH) in ${stats.total} plugins`);
    });
  
  console.log(`\nOutput saved to: ${OUTPUT_FILE}\n`);
}

function detectPlatform(pluginName, data) {
  // Try to detect from source data or filename patterns
  const lower = pluginName.toLowerCase();
  
  if (data.vulnerabilities && data.vulnerabilities[0]?.affected?.ecosystem) {
    const ecosystem = data.vulnerabilities[0].affected.ecosystem;
    if (ecosystem === 'npm') {
      // Could be chrome, firefox, vscode, obsidian
      if (lower.includes('vscode') || lower.includes('microsoft')) return 'vscode';
      if (lower.includes('obsidian')) return 'obsidian';
      return 'chrome'; // default for npm
    }
  }
  
  // Pattern matching
  if (lower.includes('vscode') || lower.includes('microsoft')) return 'vscode';
  if (lower.includes('obsidian')) return 'obsidian';
  if (lower.includes('jetbrains')) return 'jetbrains';
  if (lower.includes('wordpress')) return 'wordpress';
  if (lower.includes('home-assistant') || lower.includes('homeassistant')) return 'homeassistant';
  if (lower.includes('minecraft')) return 'minecraft';
  if (lower.includes('sublime')) return 'sublime';
  if (lower.includes('firefox') || lower.includes('mozilla')) return 'firefox';
  
  return 'unknown';
}

main();














